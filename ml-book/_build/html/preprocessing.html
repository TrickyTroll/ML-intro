
<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traitement antérieur à l’entrainement &#8212; Introduction à la reconnaissance optique de caractère</title>
    
  <link rel="stylesheet" href="_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/translations.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="next" title="Notions de base" href="notions_de_base.html" />
    <link rel="prev" title="Les librairies nécessaires" href="explications_librairies.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  <img src="_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Introduction à la reconnaissance optique de caractère</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Rechercher dans ce livre ..." aria-label="Rechercher dans ce livre ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Préface
  </a>
 </li>
</ul>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="rapport_final.html">
   Rapport Final
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="intro_finale.html">
     Introduction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="explications_librairies.html">
     Les librairies nécessaires
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Traitement antérieur à l’entrainement
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="notions_de_base.html">
     Notions de base
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="training.html">
     L’entrainement d’un système neuronal
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="bienfaits_et_inconv%C3%A9nients.html">
     Bienfaits et inconvénients
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="conclusion.html">
     Conclusion
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zbib.html">
     Bibliographie
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Basculer la navigation" aria-controls="site-navigation"
            title="Basculer la navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Téléchargez cette page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/preprocessing.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Télécharger le fichier source" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Imprimer au format PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Mode plein écran"
                title="Mode plein écran"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contenu
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#pourquoi-faire-du-preprocessing">
   Pourquoi faire du
   <em>
    preprocessing
   </em>
   ?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mise-en-bouche-sur-lapprentissage-machine">
   Mise en bouche sur l’apprentissage machine
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#traiter-beaucoup-de-donnees">
   Traiter beaucoup de données
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#le-parallelisme">
     Le parallélisme
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#les-proprietes-des-matrices">
       Les propriétés des matrices
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#la-multiplication">
         La multiplication
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#laddition">
         L’addition
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#la-multiplication-par-un-scalaire">
         La multiplication par un scalaire
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#la-sommation">
         La sommation
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#en-bref">
         En bref
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#numpy">
     NumPy
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#blas">
       <code class="docutils literal notranslate">
        <span class="pre">
         BLAS
        </span>
       </code>
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#quelques-resultats-concrets">
       Quelques résultats concrets
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#multiplication-de-matrices-a-laide-de-numpy">
         Multiplication de matrices à l’aide de
         <code class="docutils literal notranslate">
          <span class="pre">
           NumPy
          </span>
         </code>
         .
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#sommations-de-tableaux-a-laide-de-numpy">
       Sommations de tableaux à l’aide de
       <code class="docutils literal notranslate">
        <span class="pre">
         NumPy
        </span>
       </code>
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#representer-des-images">
   Représenter des images
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#explications-plus-detaillees-sur-la-representation-des-images">
     Explications plus détaillées sur la représentation des images.
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pourquoi-le-grayscale">
       Pourquoi le
       <em>
        grayscale
       </em>
       ?
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#pourquoi-est-il-inverse">
         Pourquoi est-il inversé?
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pourquoi-seulement-784-pixels">
       Pourquoi seulement 784 pixels?
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="traitement-anterieur-a-lentrainement">
<h1>Traitement antérieur à l’entrainement<a class="headerlink" href="#traitement-anterieur-a-lentrainement" title="Lien permanent vers ce titre">¶</a></h1>
<p>Dans cette section, nous discuterons du traitement nécessaire afin d’utiliser des images pour entrainer un réseau neuronal. Nous discuterons aussi de l’importance de ce traitement, ainsi que de la raison pour laquelle il doit aussi être réalisé sur les images que nous voudrons par la suite reconnaître.</p>
<div class="section" id="pourquoi-faire-du-preprocessing">
<h2>Pourquoi faire du <em>preprocessing</em>?<a class="headerlink" href="#pourquoi-faire-du-preprocessing" title="Lien permanent vers ce titre">¶</a></h2>
<p>Comme nous en avons discuté dans la section précédente, notre programme utilise des méthodes fournies par la librairie <code class="docutils literal notranslate"><span class="pre">Tensorflow</span></code> afin de charger les données dans le bon format. Malheureusement, dans une majorité des cas, les données ne vous seront pas fournies sur un plateau d’argent. Les programmes d’apprentissage machine visent à faire du calcul statistique sur le jeu de données fourni</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Dans le domaine de l’IA, un jeu de données représente l’ensemble des données traitées ainsi que leur étiquettes.</p>
</div>
</div>
<div class="section" id="mise-en-bouche-sur-lapprentissage-machine">
<h2>Mise en bouche sur l’apprentissage machine<a class="headerlink" href="#mise-en-bouche-sur-lapprentissage-machine" title="Lien permanent vers ce titre">¶</a></h2>
<p>L’entrainement d’un modèle se rapproche beaucoup des mathématiques, plus précisément de la statistique, comme en témoigne le <em>Deep Learning Book</em> <a class="bibtex reference internal" href="zbib.html#goodfellow-et-al-2016" id="id1">[Goodfellow et al., 2016]</a>. L’apprentissage machine vise à ingérer des quantités massives de données provenant de sources différentes. Par la suite, à l’aide de calculs statistiques, le programme tente de faire une certaine classification du jeu données. Selon le besoin, le programme pourrait alors poser une étiquette sur des données non étiquetées similaires à celles retrouvées dans le jeu de donnée <span class="bibtex" id="id2">[mitclassification]</span>.   Le modèle pourrait aussi être entrainer afin de reconnaître des anomalies, grouper des informations similaires par classes et bien d’autres <span class="bibtex" id="id3">[wikisupervised]</span>. Toutes ces informations seront discutées plus en détails au courant de la prochaine section. Ce qu’il est important de retenir, c’est qu’entrainer un modèle nécessite <em><strong>beaucoup</strong></em> de données.</p>
<div class="admonition-sur-la-signification-de-beaucoup-de-donnees admonition">
<p class="admonition-title">Sur la signification de «beaucoup de données»</p>
<p>Il y a 60 000 exemples dans nos données d’entraînement.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span> <span class="p">]:</span> <span class="n">train_data</span><span class="o">.</span><span class="n">shape</span>
<span class="n">Out</span><span class="p">[</span> <span class="p">]:</span> <span class="p">(</span><span class="mi">60000</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="traiter-beaucoup-de-donnees">
<h2>Traiter beaucoup de données<a class="headerlink" href="#traiter-beaucoup-de-donnees" title="Lien permanent vers ce titre">¶</a></h2>
<p>Pour reprendre l’exemple précédent, la <code class="docutils literal notranslate"><span class="pre">shape</span></code> de l’objet <code class="docutils literal notranslate"><span class="pre">train_data</span></code>est une liste de 60 000 images représentées par des matrices carrées de dimension 28. Dans notre cas, si le programme passait tous les pixels un à un, il faudrait qu’il réalise séquentiellement <span class="math notranslate nohighlight">\(28 \times 28 \times 60 000 = 47 040 000\)</span> opérations. Ce serait par exemple le cas dans une <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">loop</span></code>. Bien que les ordinateurs modernes sont particulièrement rapides<a class="footnote-reference brackets" href="#id24" id="id4">16</a>, les modèles récents sont eux aussi entrainés avec des jeux de données de plus en plus massifs. Celui utilisé pour le service <a class="reference external" href="https://translate.google.ca">Google Translate</a>, par exemple, compte des milliards d’exemples <span class="bibtex" id="id5">[googledatasize]</span>.</p>
<p>Heureusement, il existe des méthodes permettant de paralléliser<a class="footnote-reference brackets" href="#id25" id="id6">17</a> les opérations statistiques réalisées sur notre modèle.</p>
<div class="section" id="le-parallelisme">
<h3>Le parallélisme<a class="headerlink" href="#le-parallelisme" title="Lien permanent vers ce titre">¶</a></h3>
<p>Pour réduire le coût monétaire et temporel de l’entrainement d’un modèle, la tâche peut être séparée sur plusieurs des coeurs<a class="footnote-reference brackets" href="#id26" id="id7">18</a> de la machine. Pour se faire, nous profiterons des propriétés des matrices.</p>
<div class="section" id="les-proprietes-des-matrices">
<h4>Les propriétés des matrices<a class="headerlink" href="#les-proprietes-des-matrices" title="Lien permanent vers ce titre">¶</a></h4>
<p>Afin de trouver comment il serait possible de réaliser nos calculs en parallèle, analysons les propriétés des matrices.</p>
<div class="section" id="la-multiplication">
<h5>La multiplication<a class="headerlink" href="#la-multiplication" title="Lien permanent vers ce titre">¶</a></h5>
<p>Assumons les matrices de dimensions compatibles<a class="footnote-reference brackets" href="#id27" id="id8">19</a> <span class="math notranslate nohighlight">\(A\)</span> et <span class="math notranslate nohighlight">\(B\)</span>:</p>
<p><span class="math notranslate nohighlight">\([A \times B]_{i,j} = \displaystyle\sum_{k=1}A_{i,k}B_{k,j}\)</span></p>
<p>Assumons aussi que la matrice <span class="math notranslate nohighlight">\(C\)</span> est produite par l’opération <span class="math notranslate nohighlight">\(A \times B\)</span> et que les matrices <span class="math notranslate nohighlight">\(A\)</span> et <span class="math notranslate nohighlight">\(B\)</span> sont carrées<a class="footnote-reference brackets" href="#id28" id="id9">20</a>.  Le calcul de <span class="math notranslate nohighlight">\(C\)</span> pourrait alors être implémenté de la manière suivante.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialisation de la matrice de départ.</span>
<span class="c1"># Nous assumons que les matrices sont 3x3.</span>
<span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="c1"># Pour chaque rangée de la matrice A.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
	<span class="c1"># Pour chaque valeur d&#39;une rangée de la matrice B.</span>
	<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
		<span class="c1"># Pour chaque rangée de la matrice B</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)):</span>
			<span class="c1"># [AxB]_{i,j} += A_{i,k} * B_{k, j}</span>
			<span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>Quoi qu’assez simple à implémenter, cette façon de calculer <span class="math notranslate nohighlight">\(C\)</span> est particulièrement inefficace. Alors que les matrices A et B augmentent en taille, le nombre d’opérations requises augmente…<strong>au cube!</strong> Si <span class="math notranslate nohighlight">\(A\)</span> passe d’une matrice <span class="math notranslate nohighlight">\(2X2\)</span> à une matrice <span class="math notranslate nohighlight">\(3X3\)</span>, chaque <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">loop</span></code> doit être réalisée <span class="math notranslate nohighlight">\(n\)</span><a class="footnote-reference brackets" href="#id29" id="id10">21</a> fois de plus. Comme le programme contient 3 for loops imbriquées, si la première doit être faite <span class="math notranslate nohighlight">\(n\)</span> fois de plus, alors c’est de même pour la deuxième, puis la troisième. Le calcul est alors <span class="math notranslate nohighlight">\(n \times n \times n = n^3\)</span> fois plus complexe à réaliser <span class="bibtex" id="id11">[wikimatrixmulti]</span>.</p>
<p>Heureusement, ce problème n’est pas sans issues. Reprenons l’équation de la multiplication de deux matrices.
<span class="math notranslate nohighlight">\([A \times B]_{i,j} = \displaystyle\sum_{k=1}A_{i,k}B_{k,j}\)</span>
Dans ce cas, chaque élément de <span class="math notranslate nohighlight">\(C\)</span> est produit par une sommation sur des multiplications d’éléments de <span class="math notranslate nohighlight">\(A\)</span> et <span class="math notranslate nohighlight">\(B\)</span>. Il est aussi important de noter qu’aucun calcul pour un élément de <span class="math notranslate nohighlight">\(C\)</span> dépend d’un calcul pour un autre élément de <span class="math notranslate nohighlight">\(C\)</span><a class="footnote-reference brackets" href="#id30" id="id12">22</a>. Il serait donc possible de calculer plusieurs éléments de <span class="math notranslate nohighlight">\(C\)</span> en même temps!</p>
<p>Bien que le calcul en parallèle ne réduit pas l’ordre de complexité, il permet tout de même de diviser le temps requis par le nombre de coeurs utilisés<a class="footnote-reference brackets" href="#id31" id="id13">23</a>.</p>
</div>
<div class="section" id="laddition">
<h5>L’addition<a class="headerlink" href="#laddition" title="Lien permanent vers ce titre">¶</a></h5>
<p>L’addition de deux matrices compatibles<a class="footnote-reference brackets" href="#id32" id="id14">24</a> se définit par l’addition de chacun des éléments homologues des deux matrices. Si nous reprenons les matrices carrées <span class="math notranslate nohighlight">\(A\)</span> et <span class="math notranslate nohighlight">\(B\)</span> utilisées plus haut, la somme de ces deux matrices serait:</p>
<p><span class="math notranslate nohighlight">\([A+B]_{i,j} = A_{i,j} + B_{i,j}\)</span></p>
<p>Supposons que la matrice <span class="math notranslate nohighlight">\(C\)</span> résulte de la somme de <span class="math notranslate nohighlight">\(A\)</span> et <span class="math notranslate nohighlight">\(B\)</span>. Il est encore une fois possible d’affirmer que la valeur de <span class="math notranslate nohighlight">\(C_{i,j}\)</span> ne dépend pas de la valeur de <span class="math notranslate nohighlight">\(C_{k,l}\)</span>. Il serait possible d’additionner chaque composante des deux matrices dans n’importe quel ordre en obtenant toujours le même résultat.</p>
<p>Encore une fois, l’addition de deux matrices peut être parallélisé afin de réduire le temps de calcul<a class="footnote-reference brackets" href="#id33" id="id15">25</a>.</p>
</div>
<div class="section" id="la-multiplication-par-un-scalaire">
<h5>La multiplication par un scalaire<a class="headerlink" href="#la-multiplication-par-un-scalaire" title="Lien permanent vers ce titre">¶</a></h5>
<p>Bien que la multiplication par un scalaire s’avère facile à réaliser à la main pour de petites matrices, l’opération doit tout de même être réalisée sur chaque élément de la matrice.</p>
<p><span class="math notranslate nohighlight">\( \lambda \begin{bmatrix}
    x_{11} &amp; x_{12} &amp; x_{13} &amp; \dots  &amp; x_{1n} \\
    x_{21} &amp; x_{22} &amp; x_{23} &amp; \dots  &amp; x_{2n} \\
    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    x_{d1} &amp; x_{d2} &amp; x_{d3} &amp; \dots  &amp; x_{dn}
\end{bmatrix} \)</span></p>
<p>Revient à faire le calcul:</p>
<p><span class="math notranslate nohighlight">\(\begin{bmatrix}
    \lambda x_{11} &amp; \lambda x_{12} &amp; \lambda x_{13} &amp; \dots  &amp; \lambda x_{1n} \\
    \lambda x_{21} &amp; \lambda x_{22} &amp; \lambda x_{23} &amp; \dots  &amp; \lambda x_{2n} \\
    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    \lambda x_{d1} &amp; \lambda x_{d2} &amp; \lambda x_{d3} &amp; \dots  &amp; \lambda x_{dn}
\end{bmatrix}\)</span></p>
<p>Encore une fois, aucun résultat n’est dépendant d’un autre. Il serait donc possible d’effectuer plusieurs multiplications en même temps, puis grouper les résultats dans une matrice.</p>
</div>
<div class="section" id="la-sommation">
<h5>La sommation<a class="headerlink" href="#la-sommation" title="Lien permanent vers ce titre">¶</a></h5>
<p>Nous avons ici un calcul légèrement différent des autres. Dans le cas de la sommation des éléments d’une matrice de dimension <span class="math notranslate nohighlight">\((1,n)\)</span>, le calcul s’avère commutatif en plus d’être associatif<a class="footnote-reference brackets" href="#id34" id="id16">26</a>. La commutativité de l’addition permet à notre programme d’utiliser l’opérateur de réduction.</p>
<div class="admonition-l-operateur-de-reduction admonition">
<p class="admonition-title">L’opérateur de réduction</p>
<p>Un opérateur de réduction permet de réduire les éléments d’un <a class="reference external" href="https://fr.wikipedia.org/wiki/Tableau_(structure_de_donn%C3%A9es)">tableau</a> à un seul résultat. <span class="bibtex" id="id17">[wikireducop]</span></p>
</div>
<p>En premier lieu, voici comme une addition séquentielle d’un tableau pourrait être réalisé. Assumons un tableau de 8 entiers comme suit: <code class="docutils literal notranslate"><span class="pre">tableau</span> <span class="pre">=</span> <span class="pre">[2,9,6,4,1,3,8,8]</span></code>. L’addition pourrait alors être réalisée en ajoutant chaque nombre un par un jusqu’à obtenir le total.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Création du tableau.</span>
<span class="n">tableau</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="c1"># Initiation de la variable `somme`.</span>
<span class="n">somme</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># Pour chaque chiffre dans le tableau.</span>
<span class="k">for</span> <span class="n">chiffre</span> <span class="ow">in</span> <span class="n">tableau</span><span class="p">:</span>
    <span class="c1"># Sommation de l&#39;ancienne somme avec le nouveau chiffre.</span>
    <span class="n">somme</span> <span class="o">+=</span> <span class="n">chiffre</span>
<span class="c1"># Affichage de la somme.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">somme</span><span class="p">)</span>
</pre></div>
</div>
<p>Cet exemple permettrait de réaliser une sommation séquentielle sur tous les chiffres contenus dans le tableau. Ce reviendrait à réaliser le calcul suivant:
<span class="math notranslate nohighlight">\((((((((2+9)+6)+4)+1)+3)+8)+8)\)</span>
Bien que la moindre performance de cette méthode ne se fait pas ressentir pour des petites sommations, ce programme ne s’adapte pas bien à de grands tableaux<a class="footnote-reference brackets" href="#id35" id="id18">27</a>.</p>
<p>Ensuite, si l’addition n’était qu’associative, l’opération pourrait tout de même être parallélisée. Les sommes partielles pourraient être calculées indépendamment les unes des autres comme pour les autres opérations matricielles. Le calcul serait similaire à celui ci:
<span class="math notranslate nohighlight">\(((2+1)+(9+3))+((6+8)+(4+8))\)</span>
Dans cet exemple, les sommes <span class="math notranslate nohighlight">\(2+1\)</span>, <span class="math notranslate nohighlight">\(9+3\)</span>, <span class="math notranslate nohighlight">\(6+8\)</span> et <span class="math notranslate nohighlight">\(4+8\)</span> sont calculées en même temps. Par contre, lorsque l’une des opérations est complétée avant une autre, il arrive que l’ordinateur ait à attendre <span class="bibtex" id="id19">[stackoverflowcommutativity]</span>. Le coeur ne pourrait alors pas se libérer pour faire d’autres opérations. Par exemple, assumons un ordinateur possédant deux unités de calcul disponibles et une addition non commutative. Si le calcul de <span class="math notranslate nohighlight">\(2+9\)</span> était complété avant celui de <span class="math notranslate nohighlight">\(9+3\)</span>, l’ordinateur devrait attendre que les deux calculs soient complétés avant de calculer la somme partielle <span class="math notranslate nohighlight">\((2+9)+(9+3)\)</span>. Heureusement, l’addition est associative. L’ordinateur ira donc écrire le résultat de la première opération complétée à la somme partielle, sans se soucier de la complétion de l’autre opération. L’unité de calcul sera alors libérée pour calculer, par exemple, la somme <span class="math notranslate nohighlight">\(6+8\)</span>.</p>
<p>Finalement , l’opérateur de réduction est beaucoup plus adapté aux échelles de l’intelligence artificielle. Encore une fois, l’ordinateur sépare la sommation en plusieurs petites opérations qui peuvent être exécutés en parallèle. De plus, l’opérateur profite de l’associativité pour optimiser la tâche au maximum. À la fin de la réduction, il ne reste qu’une seule addition. Le calcul mathématique serait par contre identique au précédent.
<span class="math notranslate nohighlight">\(((2+1)+(9+3))+((6+8)+(4+8))\)</span>
Il est possible de remarquer que l’addition est fait dans un ordre particulier. Cet ordre donne un meilleur modèle d’accès à la mémoire.</p>
<p>Python utilise l’opérateur de réduction lors du calcul de sommations. Implémenter ce genre de solution s’avère donc assez simple.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tableau</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="n">somme</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">somme</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">NumPy</span></code> possède aussi une fonction de sommation optimisée pour les <code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">arrays</span></code>. Elle peut être implémentée tout aussi simplement.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">tableau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="n">somme</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">somme</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="en-bref">
<h5>En bref<a class="headerlink" href="#en-bref" title="Lien permanent vers ce titre">¶</a></h5>
<p>En bref, une majorité des opérations matricielles peuvent être parallélisées. Les matrices sont donc la représentation de choix pour les jeux de données dans le domaine de l’intelligence artificielle. La transformation du jeu de données en matrices est une partie majeure du <em>preprocessing</em>. Elle permet d’accélérer le calcul d’un facteur non-négligeable.</p>
</div>
</div>
</div>
<div class="section" id="numpy">
<h3>NumPy<a class="headerlink" href="#numpy" title="Lien permanent vers ce titre">¶</a></h3>
<p>C’est pour les opérations parallèles que la librairie <code class="docutils literal notranslate"><span class="pre">numpy</span></code>, mentionnée lors de la section précédente, entre en jeu. Les opérations matricielles réalisées à l’aide de méthodes implémentés par <code class="docutils literal notranslate"><span class="pre">numpy</span></code>profitent aussi de l’implémentation des <code class="docutils literal notranslate"><span class="pre">BLAS</span></code><a class="footnote-reference brackets" href="#id36" id="id20">28</a>. Les <code class="docutils literal notranslate"><span class="pre">BLAS</span></code> permettent de grandement accélérer nos calculs sans même nécessiter de coeurs supplémentaires. Elles exploitent plutôt les différentes architectures de processeur ainsi que leur différents niveau de cache<a class="footnote-reference brackets" href="#id37" id="id21">29</a>.</p>
<div class="section" id="blas">
<h4><code class="docutils literal notranslate"><span class="pre">BLAS</span></code><a class="headerlink" href="#blas" title="Lien permanent vers ce titre">¶</a></h4>
<p>Les sous-routines d’algèbre linéaire permettent de nettement réduire l’ordre de complexité des opérations d’algèbre linéaire. Elles permettent, par exemple, de décomposer des matrices en blocs afin d’accélérer la multiplication.</p>
<p>Ces sous-programmes sont extrêmement populaires. Ils sont implémentés dans une majorité des programmes de calcul scientifique <span class="bibtex" id="id22">[blaswebsite]</span>.</p>
</div>
<div class="section" id="quelques-resultats-concrets">
<h4>Quelques résultats concrets<a class="headerlink" href="#quelques-resultats-concrets" title="Lien permanent vers ce titre">¶</a></h4>
<p>Voici quelques résultats plus concrets permettant d’obtenir une meilleure idée de l’ampleur de l’accélération des calculs.</p>
<div class="section" id="multiplication-de-matrices-a-laide-de-numpy">
<h5>Multiplication de matrices à l’aide de <code class="docutils literal notranslate"><span class="pre">NumPy</span></code>.<a class="headerlink" href="#multiplication-de-matrices-a-laide-de-numpy" title="Lien permanent vers ce titre">¶</a></h5>
<p>Dans ce programme, deux matrices de dimensions <span class="math notranslate nohighlight">\(1000 x 1000\)</span> sont multipliées. La méthode de base avec les itérations imbriquées est comparée avec l’implémentation de l’opération par la librairie <code class="docutils literal notranslate"><span class="pre">NumPy</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Création de nos matrices</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">))</span>

<span class="c1"># Test de la première implémentation</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
	<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)):</span>
		<span class="c1"># 	print(A[i][k])</span>
<span class="c1"># 			print(B[k][j])</span>
<span class="c1"># 			print(i,j)</span>
			<span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
			
<span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">time_1</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>

<span class="c1"># Test de l&#39;implémentation avec Numpy</span>
<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">B</span>

<span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">time_2</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Run time 1 = </span><span class="si">{}</span><span class="s2"> seconds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Run time numpy = </span><span class="si">{}</span><span class="s2"> seconds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_2</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Run</span> <span class="n">time</span> <span class="mi">1</span> <span class="o">=</span> <span class="mf">1838.9336512088776</span> <span class="n">seconds</span>
<span class="n">Run</span> <span class="n">time</span> <span class="n">numpy</span> <span class="o">=</span> <span class="mf">0.005700111389160156</span> <span class="n">seconds</span>
</pre></div>
</div>
<p>Alors que l’implémentation de base prend plus de 30 minutes à faire le calcul, <code class="docutils literal notranslate"><span class="pre">Numpy</span></code> n’a besoin de que moins de 6 millièmes de secondes<a class="footnote-reference brackets" href="#id38" id="id23">30</a>!</p>
</div>
</div>
<div class="section" id="sommations-de-tableaux-a-laide-de-numpy">
<h4>Sommations de tableaux à l’aide de <code class="docutils literal notranslate"><span class="pre">NumPy</span></code><a class="headerlink" href="#sommations-de-tableaux-a-laide-de-numpy" title="Lien permanent vers ce titre">¶</a></h4>
<p>Dans cet autre programme démontre quant à lui la différence entre notre implémentation de base de la sommation avec celle de <code class="docutils literal notranslate"><span class="pre">NumPy</span></code> sur un <code class="docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>. La sommation se fait sur 1 milliard d’éléments aléatoires entre <span class="math notranslate nohighlight">\(0\)</span> et <span class="math notranslate nohighlight">\(1\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Création du tableau et initiation de la somme.</span>
<span class="n">tableau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000000000</span><span class="p">)</span>
<span class="n">somme</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># Test de la première implémentation.</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># Pour chaque chiffre dans le tableau.</span>
<span class="k">for</span> <span class="n">chiffre</span> <span class="ow">in</span> <span class="n">tableau</span><span class="p">:</span>
    <span class="c1"># Sommation de l&#39;ancienne somme avec le nouveau chiffre.</span>
    <span class="n">somme</span> <span class="o">+=</span> <span class="n">chiffre</span>
			
<span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">time_1</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>

<span class="c1"># Test de l&#39;implémentation avec Numpy.</span>

<span class="c1"># Réinitialisation de la somme.</span>
<span class="n">somme</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">somme</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span>

<span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">time_2</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Run time 1 = </span><span class="si">{}</span><span class="s2"> seconds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Run time numpy = </span><span class="si">{}</span><span class="s2"> seconds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time_2</span><span class="p">))</span>
</pre></div>
</div>
<p>La différence entre les résultats est encore une fois majeure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Run</span> <span class="n">time</span> <span class="mi">1</span> <span class="o">=</span> <span class="mf">361.87627387046814</span> <span class="n">seconds</span>
<span class="n">Run</span> <span class="n">time</span> <span class="n">numpy</span> <span class="o">=</span> <span class="mf">5.082181215286255</span> <span class="n">seconds</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="representer-des-images">
<h2>Représenter des images<a class="headerlink" href="#representer-des-images" title="Lien permanent vers ce titre">¶</a></h2>
<p>Pour notre programme, l’intrant de notre réseau neuronal sera constitué d’images. Par contre, ces images ne seront pas directement passées au travers de notre programme dans leur format d’origine.</p>
<p>Comme discuté dans la section précédente, il serait préférable que les images soient représentées sous forme de matrices. C’est heureusement déjà le cas de nos données d’entrainement.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span> <span class="p">]:</span> <span class="nb">type</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span> <span class="p">]:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span>
</pre></div>
</div>
<p>Dans cet exemple, <code class="docutils literal notranslate"><span class="pre">train_data</span></code> est un <code class="docutils literal notranslate"><span class="pre">array</span></code> contenant l’ensemble de nos images. Pour obtenir le nombre d’éléments dans cet <code class="docutils literal notranslate"><span class="pre">array</span></code>, la méthode <code class="docutils literal notranslate"><span class="pre">shape</span></code> peut être utilisée.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span> <span class="p">]:</span> <span class="n">train_data</span><span class="o">.</span><span class="n">shape</span>
<span class="n">Out</span><span class="p">[</span> <span class="p">]:</span> <span class="p">(</span><span class="mi">60000</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
</pre></div>
</div>
<p>La première valeur correspond au nombre d’image dans nos données d’entrainement. Les deux valeurs suivantes sont le nombre de rangées et de colonnes des matrices utilisées pour représenter ces mêmes images. Ce sont donc des matrices carrées de dimensions <span class="math notranslate nohighlight">\(n = 28\)</span>.</p>
<p>Afin d’analyser précisément l’une de ces images, imprimons l’une des rangées de pixels.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span> <span class="p">]:</span> <span class="n">train_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">20</span><span class="p">]</span>
<span class="n">Out</span><span class="p">[</span> <span class="p">]:</span> <span class="n">array</span><span class="p">([</span>  <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   
                 <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  
                 <span class="mi">24</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">221</span><span class="p">,</span>  <span class="mi">253</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span> 
                 <span class="mi">253</span><span class="p">,</span> <span class="mi">253</span><span class="p">,</span> <span class="mi">201</span><span class="p">,</span>  <span class="mi">78</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>
                 <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>
                 <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>
</pre></div>
</div>
<p>Les pixels sont représentés par des valeurs <em>grayscale</em> inversées. Traditionnellement, une valeur <em>grayscale</em> est élevée lorsque le pixel est très illuminé. La valeur maximale de <code class="docutils literal notranslate"><span class="pre">255</span></code>signifie un blanc, alors que le <code class="docutils literal notranslate"><span class="pre">0</span></code>correspond au noir. Dans notre jeu de données, ces deux valeurs sont inversées. Une valeur élevée signifie un pixel plus sombre.</p>
<p>Le paramètre <code class="docutils literal notranslate"><span class="pre">dtype=uint8</span></code>signifie que nos pixels sont représentés par des entiers de 8 bits. Chaque bit ne pouvant avoir une valeur que de 1 ou 0, le plus grand nombre pouvant être représenté par ce type d’entier est 255.</p>
<div class="section" id="explications-plus-detaillees-sur-la-representation-des-images">
<h3>Explications plus détaillées sur la représentation des images.<a class="headerlink" href="#explications-plus-detaillees-sur-la-representation-des-images" title="Lien permanent vers ce titre">¶</a></h3>
<p>Cette section c’est seulement si j’ai le temps.</p>
<div class="section" id="pourquoi-le-grayscale">
<h4>Pourquoi le <em>grayscale</em>?<a class="headerlink" href="#pourquoi-le-grayscale" title="Lien permanent vers ce titre">¶</a></h4>
<div class="section" id="pourquoi-est-il-inverse">
<h5>Pourquoi est-il inversé?<a class="headerlink" href="#pourquoi-est-il-inverse" title="Lien permanent vers ce titre">¶</a></h5>
</div>
</div>
<div class="section" id="pourquoi-seulement-784-pixels">
<h4>Pourquoi seulement 784 pixels?<a class="headerlink" href="#pourquoi-seulement-784-pixels" title="Lien permanent vers ce titre">¶</a></h4>
<hr class="docutils" />
<dl class="footnote brackets">
<dt class="label" id="id24"><span class="brackets"><a class="fn-backref" href="#id4">16</a></span></dt>
<dd><p>Un ordinateur moderne possédant un processeur de 2GHz peut réaliser 2 000 000 000 opérations par seconde sur chacun de ses coeurs.</p>
</dd>
<dt class="label" id="id25"><span class="brackets"><a class="fn-backref" href="#id6">17</a></span></dt>
<dd><p>Exécuter plusieurs opérations parallèlement plutôt que séquentiellement.</p>
</dd>
<dt class="label" id="id26"><span class="brackets"><a class="fn-backref" href="#id7">18</a></span></dt>
<dd><p>Un «coeur» est une unité du processeur pouvant faire du calcul indépendamment des autres coeurs. Un processeur d’ordinateur portable moderne possède de deux à quatre coeurs. Une carte graphique moderne en possède quelques milliers, quoique moins performants que ceux du processeur.</p>
</dd>
<dt class="label" id="id27"><span class="brackets"><a class="fn-backref" href="#id8">19</a></span></dt>
<dd><p>Pour réaliser une multiplication entre deux matrices, il faut que le nombre de colonnes de la première matrice soit égal au nombre de rangées de la deuxième.</p>
</dd>
<dt class="label" id="id28"><span class="brackets"><a class="fn-backref" href="#id9">20</a></span></dt>
<dd><p>Une matrice carrée est une matrice qui contient autant de rangées que de colonnes.</p>
</dd>
<dt class="label" id="id29"><span class="brackets"><a class="fn-backref" href="#id10">21</a></span></dt>
<dd><p><span class="math notranslate nohighlight">\(n\)</span> représente le nombre de rangées et de colonnes d’une matrice carrée.</p>
</dd>
<dt class="label" id="id30"><span class="brackets"><a class="fn-backref" href="#id12">22</a></span></dt>
<dd><p>Ils peuvent être calculés dans n’importe quel ordre et le résultat sera toujours le même. Un résultat pourrait aussi</p>
</dd>
<dt class="label" id="id31"><span class="brackets"><a class="fn-backref" href="#id13">23</a></span></dt>
<dd><p>Plus ou moins. Voir <a class="reference external" href="https://en.wikipedia.org/wiki/Parallel_computing#Amdahl%27s_law_and_Gustafson%27s_law">1.1 Amdahl’s law and Gustafson’s law</a></p>
</dd>
<dt class="label" id="id32"><span class="brackets"><a class="fn-backref" href="#id14">24</a></span></dt>
<dd><p>Pour que deux matrices puissent être additionnées, elles doivent avoir le même nombre de rangées et de colonnes.</p>
</dd>
<dt class="label" id="id33"><span class="brackets"><a class="fn-backref" href="#id15">25</a></span></dt>
<dd><p>En assumant que le calcul est réalisé sur une machine possédant plusieurs coeurs.</p>
</dd>
<dt class="label" id="id34"><span class="brackets"><a class="fn-backref" href="#id16">26</a></span></dt>
<dd><p>Dans le cas des autres opérations matricielles présentées, elles étaient seulement associatives. Les calculs étaient, comme pour la sommation, indépendants les un des autres. Par contre, pour les autres opérations les résultats devaient être placés de manière ordonnée dans la matrice résultante.</p>
</dd>
<dt class="label" id="id35"><span class="brackets"><a class="fn-backref" href="#id18">27</a></span></dt>
<dd><p>Voir la {section} sur les résultats concrets.</p>
</dd>
<dt class="label" id="id36"><span class="brackets"><a class="fn-backref" href="#id20">28</a></span></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">BLAS</span></code> signifie <strong>B</strong>asic <strong>L</strong>inear <strong>A</strong>lgebra <strong>S</strong>ubroutines, ou sous-routines de base d’algèbre linéaire.</p>
</dd>
<dt class="label" id="id37"><span class="brackets"><a class="fn-backref" href="#id21">29</a></span></dt>
<dd><p>Petite mémoire rapide allouée au processeur.</p>
</dd>
<dt class="label" id="id38"><span class="brackets"><a class="fn-backref" href="#id23">30</a></span></dt>
<dd><p>Testé sur un processeur <em>2.9 GHz Dual-Core Intel Core i5</em>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="explications_librairies.html" title="previous page">Les librairies nécessaires</a>
    <a class='right-next' id="next-link" href="notions_de_base.html" title="next page">Notions de base</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Émile Bergeron, Samuel Paquin, Étienne Parent, Jérémie Sanfaçon<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.3da636dd464baa7582d2.js"></script>


    
  </body>
</html>